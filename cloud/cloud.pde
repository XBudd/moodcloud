/* Colin Budd - 5/14/2016
 * "weather@mood.cloud"
 * Cornell University
 * Modified version of original mood.cloud.
 * Check out more of my work at www.xbudd.com #shameless
 */

// Note: data is collected from weatherLog.cv (generated by running 
// cloud_online_resources.pde alongside this sketch.)
// The data is handled in seperate pde so as to avoid the animation lag experienced
// by overloading this pde with the task of seeking and parsing weather data. 

//---WELCOME TO WEATHER@MOOD.CLOUD---//

//loading necessary libraries and pre-setting 
import gab.opencv.*;
OpenCV opencv;
ArrayList<Contour> contours;
int contoursCount;
// For testing animation without Teensy borad
boolean testWidthOutTeensy = false; 
readTable rt;
boolean dayLight = false;

int time;  

// Setting basic info for Animations (movement of "cloud" blobs)
ArrayList<Ani> anis;
color[] colorArray = new color[10]; //keep at 10 - defines the color range
int lastInteractionMillis = 0;
int cloudDensity = 5; // 1~10 -- how bright the LEDs are
int windSpeed;
int skyBright;
int cloudAnimationInterval = 10; // Seconds

// Set starting info for cloud's background and floating colors
color bg = (0);
color cloudColor = (255);

void setup() {
  // Basics of stage
  size(180, 24, P3D);
  background(bg);
  frameRate(30);
  
  // Create and call weather table reader
  rt = new readTable();
  rt.getTable();
  windSpeed =int(map(rt.getWindSpeed(), 0.0, 100.0, 3.0, 60.0));
  skyBright = rt.getSkyBright();
  cloudDensity = skyBright; //set LED intensity to match outside brightness
  
  // LED Control - hardware functionality
  if (!testWidthOutTeensy) {
    String[] list = Serial.list();
    delay(20);
    println("Serial Ports List:");
    println(list);
    serialConfigure("COM3");  // change these to your port names
    if (errorCount > 0) exit();
    for (int i=0; i < 256; i++) {
      gammatable[i] = (int)(pow((float)i / 255.0, gamma) * 255.0 + 0.5);
    }
  }

  // Load Animations
  anis = new ArrayList<Ani>();

  // Run Cloud Animation
  clouds = new ArrayList<CloudAni>();
  for (int i=0; i<20; i++) {
    clouds.add(new CloudAni());
  }
  resetPositions();
 
 // led colors
  colorArray[1] = color(255, 10, 10); //red
  colorArray[0] = color(255, 190, 0); //orange
  //  colorArray[0] = color(255,30,100); //pink
  colorArray[2] = color(255, 245, 0); //yellow
  colorArray[3] = color(255, 190, 0); //orange

  colorArray[4] = color(51, 255, 71); //green
  colorArray[5] = color(51, 204, 151); //teal
  colorArray[6] = color(80, 0, 255); //blue
  colorArray[7] = color(20, 255, 255); //light blue
  colorArray[8] = color(138, 0, 255); //purple
  colorArray[9] = color(153, 153, 153); //white
}

void draw() {
  if (minute() % 5 == 0 & millis() == 50000) { //every 5 mins and 50 seconds
    rt.getTable(); //check for new weather
  } 

  cloudDensity = skyBright;
  updateCloudAni(); 


// Draw the background gradient 
  drawGradient();
  if (lastInteractionMillis < millis() - cloudAnimationInterval * 1000) {
    //set background to black
    fill(0,0,0);
    rect(0, 0, width, height);
    updateCloudAni(); 
  }
  
  updateAni();
  if (!testWidthOutTeensy) {
    sendData();
  }

}

// You can test colors simply by typing numbers. 
// Continuously preserves that color in the LED bands.
void keyPressed() {
  println(keyCode);
  if (keyCode > 48 & keyCode < 54) {
    anis.add(new Ani(colorArray[(keyCode-49) * 2], keyCode-48));
  }

}
// You can test an update of weather data by clicking on the canvas.
void mouseClicked() {
  rt.getTable();
   windSpeed =int(map(rt.getWindSpeed(), 0.0, 100.0, 3.0, 60.0));
 cloudDensity = skyBright;
}

